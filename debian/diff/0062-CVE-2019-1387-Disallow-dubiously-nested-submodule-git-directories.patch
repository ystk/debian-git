From 14cb8e044867e60262877db3f4e686142cf870b5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Roberto=20C=2E=20S=C3=A1nchez?= <roberto@debian.org>
Date: Mon, 6 Jan 2020 21:49:50 -0500
Subject: [PATCH] Disallow dubiously-nested submodule git directories

commit a8dee3ca610f5a1d403634492136c887f83b59d2 upstream.

Currently it is technically possible to let a submodule's git
directory point right into the git dir of a sibling submodule.

Example: the git directories of two submodules with the names `hippo`
and `hippo/hooks` would be `.git/modules/hippo/` and
`.git/modules/hippo/hooks/`, respectively, but the latter is already
intended to house the former's hooks.

In most cases, this is just confusing, but there is also a (quite
contrived) attack vector where Git can be fooled into mistaking remote
content for file contents it wrote itself during a recursive clone.

Let's plug this bug.

To do so, we introduce the new function `validate_submodule_git_dir()`
which simply verifies that no git dir exists for any leading directories
of the submodule name (if there are any).

Note: this patch specifically continues to allow sibling modules names
of the form `core/lib`, `core/doc`, etc, as long as `core` is not a
submodule name.

This fixes CVE-2019-1387.
---
 builtin/submodule--helper.c | 21 +++++++++++++++++++
 git-submodule.sh            | 10 +++++++++
 submodule.c                 | 41 +++++++++++++++++++++++++++++++++++++
 submodule.h                 |  5 +++++
 t/t7415-submodule-names.sh  | 23 +++++++++++++++++++++
 5 files changed, 100 insertions(+)

diff --git a/builtin/submodule--helper.c b/builtin/submodule--helper.c
index cc79d05..09ffc83 100644
--- a/builtin/submodule--helper.c
+++ b/builtin/submodule--helper.c
@@ -25,11 +25,32 @@ static int check_name(int argc, const char **argv, const char *prefix)
 	return 0;
 }
 
+/*
+ * Exit non-zero if the proposed submodule repository path is inside
+ * another submodules' git dir.
+ */
+static int validate_git_dir(int argc, const char **argv, const char *prefix)
+{
+	char *sm_gitdir;
+
+	if (argc != 3)
+		usage("git submodule--helper validate-git-dir <path> <name>");
+	sm_gitdir = xstrdup(argv[1]);
+	if (validate_submodule_git_dir(sm_gitdir, argv[2]) < 0) {
+		free(sm_gitdir);
+		return 1;
+	}
+	free(sm_gitdir);
+	return 0;
+}
+
 int cmd_submodule__helper(int argc, const char **argv, const char *prefix)
 {
 	if (argc < 2)
 		usage("git submodule--helper <command>");
 	if (!strcmp(argv[1], "check-name"))
 		return check_name(argc - 1, argv + 1, prefix);
+	if (!strcmp(argv[1], "validate-git-dir"))
+		return validate_git_dir(argc - 1, argv + 1, prefix);
 	die(_("'%s' is not a valid submodule--helper subcommand"), argv[1]);
 }
diff --git a/git-submodule.sh b/git-submodule.sh
index 1d4df90..09290e9 100755
--- a/git-submodule.sh
+++ b/git-submodule.sh
@@ -506,6 +506,11 @@ Use -f if you really want to add it." >&2
 				echo "$(eval_gettext "Reactivating local git directory for submodule '\$sm_name'.")"
 			fi
 		fi
+		sm_gitdir=".git/modules/$sm_name"
+		if ! git submodule--helper validate-git-dir "$sm_gitdir" "$sm_name"
+		then
+			die "$(eval_gettextln "refusing to create/use '\$sm_gitdir' in another submodule's git dir")"
+		fi
 		module_clone "$sm_path" "$sm_name" "$realrepo" "$reference" "$depth" || exit
 		(
 			clear_local_git_env
@@ -874,6 +879,11 @@ Maybe you want to use 'update --init'?")"
 
 		if ! test -d "$sm_path"/.git && ! test -f "$sm_path"/.git
 		then
+			sm_gitdir=".git/modules/$name"
+			if ! git submodule--helper validate-git-dir "$sm_gitdir" "$name"
+			then
+				die "$(eval_gettextln "refusing to create/use '\$sm_gitdir' in another submodule's git dir")"
+			fi
 			module_clone "$sm_path" "$name" "$url" "$reference" "$depth" || exit
 			cloned_modules="$cloned_modules;$name"
 			subsha1=
diff --git a/submodule.c b/submodule.c
index 3789145..0b6b2d3 100644
--- a/submodule.c
+++ b/submodule.c
@@ -1162,3 +1162,44 @@ void connect_work_tree_and_git_dir(const char *work_tree, const char *git_dir)
 	strbuf_release(&rel_path);
 	free((void *)real_work_tree);
 }
+
+int validate_submodule_git_dir(char *git_dir, const char *submodule_name)
+{
+	size_t len = strlen(git_dir), suffix_len = strlen(submodule_name);
+	char *p;
+	int ret = 0;
+
+	if (len <= suffix_len || (p = git_dir + len - suffix_len)[-1] != '/' ||
+	    strcmp(p, submodule_name))
+		die("BUG: submodule name '%s' not a suffix of git dir '%s'",
+		    submodule_name, git_dir);
+
+	/*
+	 * We prevent the contents of sibling submodules' git directories to
+	 * clash.
+	 *
+	 * Example: having a submodule named `hippo` and another one named
+	 * `hippo/hooks` would result in the git directories
+	 * `.git/modules/hippo/` and `.git/modules/hippo/hooks/`, respectively,
+	 * but the latter directory is already designated to contain the hooks
+	 * of the former.
+	 */
+	for (; *p; p++) {
+		if (is_dir_sep(*p)) {
+			char c = *p;
+
+			*p = '\0';
+			if (is_git_directory(git_dir))
+				ret = -1;
+			*p = c;
+
+			if (ret < 0)
+				return error(_("submodule git dir '%s' is "
+					       "inside git dir '%.*s'"),
+					     git_dir,
+					     (int)(p - git_dir), git_dir);
+		}
+	}
+
+	return 0;
+}
diff --git a/submodule.h b/submodule.h
index f0e7a71..3f16015 100644
--- a/submodule.h
+++ b/submodule.h
@@ -42,6 +42,11 @@ int find_unpushed_submodules(unsigned char new_sha1[20], const char *remotes_nam
 int push_unpushed_submodules(unsigned char new_sha1[20], const char *remotes_name);
 void connect_work_tree_and_git_dir(const char *work_tree, const char *git_dir);
 
+/*
+ * Make sure that no submodule's git dir is nested in a sibling submodule's.
+ */
+int validate_submodule_git_dir(char *git_dir, const char *submodule_name);
+
 /*
  * Returns 0 if the name is syntactically acceptable as a submodule "name"
  * (e.g., that may be found in the subsection of a .gitmodules file) and -1
diff --git a/t/t7415-submodule-names.sh b/t/t7415-submodule-names.sh
index 53a0064..524c8f6 100755
--- a/t/t7415-submodule-names.sh
+++ b/t/t7415-submodule-names.sh
@@ -182,4 +182,27 @@ test_expect_success MINGW 'prevent git~1 squatting on Windows' '
 	! grep gitdir squatting-clone/d/a/git~2
 '
 
+test_expect_success 'git dirs of sibling submodules must not be nested' '
+	git init nested &&
+	(
+		cd nested &&
+		test_commit nested &&
+		cat >.gitmodules <<-EOF &&
+		[submodule "hippo"]
+			url = .
+			path = thing1
+		[submodule "hippo/hooks"]
+			url = .
+			path = thing2
+		EOF
+		git clone . thing1 &&
+		git clone . thing2 &&
+		git add .gitmodules thing1 thing2 &&
+		test_tick &&
+		git commit -m nested
+	) &&
+	test_must_fail git clone --recurse-submodules nested clone 2>err &&
+	test_i18ngrep "is inside git dir" err
+'
+
 test_done
-- 
2.20.1

