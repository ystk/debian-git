From 40339230c0f2a982b8bd9fbcc2f5c88dab4d2eb2 Mon Sep 17 00:00:00 2001
From: Jeff King <peff@peff.net>
Date: Mon, 30 Apr 2018 03:25:25 -0400
Subject: submodule-config: verify submodule names as paths

commit 0383bbb9015898cbc79abd7b64316484d7713b44 upstream.

Submodule "names" come from the untrusted .gitmodules file,
but we blindly append them to $GIT_DIR/modules to create our
on-disk repo paths. This means you can do bad things by
putting "../" into the name (among other things).

Let's sanity-check these names to avoid building a path that
can be exploited. There are two main decisions:

  1. What should the allowed syntax be?

     It's tempting to reuse verify_path(), since submodule
     names typically come from in-repo paths. But there are
     two reasons not to:

       a. It's technically more strict than what we need, as
          we really care only about breaking out of the
          $GIT_DIR/modules/ hierarchy.  E.g., having a
          submodule named "foo/.git" isn't actually
          dangerous, and it's possible that somebody has
          manually given such a funny name.

       b. Since we'll eventually use this checking logic in
          fsck to prevent downstream repositories, it should
          be consistent across platforms. Because
          verify_path() relies on is_dir_sep(), it wouldn't
          block "foo\..\bar" on a non-Windows machine.

  2. Where should we enforce it? These days most of the
     .gitmodules reads go through submodule-config.c, so
     I've put it there in the reading step. That should
     cover all of the C code.

     We also construct the name for "git submodule add"
     inside the git-submodule.sh script. This is probably
     not a big deal for security since the name is coming
     from the user anyway, but it would be polite to remind
     them if the name they pick is invalid (and we need to
     expose the name-checker to the shell anyway for our
     test scripts).

     This patch issues a warning when reading .gitmodules
     and just ignores the related config entry completely.
     This will generally end up producing a sensible error,
     as it works the same as a .gitmodules file which is
     missing a submodule entry (so "submodule update" will
     barf, but "git clone --recurse-submodules" will print
     an error but not abort the clone.

     There is one minor oddity, which is that we print the
     warning once per malformed config key (since that's how
     the config subsystem gives us the entries). So in the
     new test, for example, the user would see three
     warnings. That's OK, since the intent is that this case
     should never come up outside of malicious repositories
     (and then it might even benefit the user to see the
     message multiple times).

Credit for finding this vulnerability and the proof of
concept from which the test script was adapted goes to
Etienne Stalmans.

[jn: backported to 2.1.y:
 - adding a skeletal git submodule--helper command to house
   the new check-name subcommand. The full submodule--helper
   was not introduced until v2.7.0-rc0~136^2~2 (submodule:
   rewrite `module_list` shell function in C, 2015-09-02).
 - calling 'git submodule--helper check-name' to validate
   submodule names in git-submodule.sh::module_name(). That
   shell function was rewritten in C in v2.7.0-rc0~136^2~1
   (submodule: rewrite `module_name` shell function in C,
   2015-09-02).
 - propagating the error from module_name in cmd_foreach.
   Without that change, the script passed to 'git submodule
   foreach' would see an empty $name for submodules with
   invalid name. The same bug still exists in v2.17.1.
 - ported the checks in C from the submodule-config API
   introduced in v2.6.0-rc0~24^2~3 (submodule: implement a
   config API for lookup of .gitmodules values, 2015-08-17)
   to the older submodule API.
 - the original patch expects 'git clone' to succeed in the
   test because v2.13.0-rc0~10^2~3 (clone: teach
   --recurse-submodules to optionally take a pathspec,
   2017-03-17) makes 'git clone' skip invalid submodules.
   Updated the test to pass in older Git versions where the
   submodule name check makes 'git clone' fail.]

Signed-off-by: Jeff King <peff@peff.net>
Signed-off-by: Jonathan Nieder <jrnieder@gmail.com>
---
 .gitignore                  |  1 +
 Makefile                    |  1 +
 builtin.h                   |  1 +
 builtin/submodule--helper.c | 35 +++++++++++++++++
 git-submodule.sh            | 21 +++++++++-
 git.c                       |  1 +
 submodule.c                 | 29 ++++++++++++++
 submodule.h                 |  7 ++++
 t/t7415-submodule-names.sh  | 77 +++++++++++++++++++++++++++++++++++++
 9 files changed, 172 insertions(+), 1 deletion(-)
 create mode 100644 builtin/submodule--helper.c
 create mode 100755 t/t7415-submodule-names.sh

diff --git a/.gitignore b/.gitignore
index 81e12c0621..58c155bafb 100644
--- a/.gitignore
+++ b/.gitignore
@@ -154,6 +154,7 @@
 /git-status
 /git-stripspace
 /git-submodule
+/git-submodule--helper
 /git-svn
 /git-symbolic-ref
 /git-tag
diff --git a/Makefile b/Makefile
index 1ddc8f97ce..bffe375565 100644
--- a/Makefile
+++ b/Makefile
@@ -1001,6 +1001,7 @@ BUILTIN_OBJS += builtin/shortlog.o
 BUILTIN_OBJS += builtin/show-branch.o
 BUILTIN_OBJS += builtin/show-ref.o
 BUILTIN_OBJS += builtin/stripspace.o
+BUILTIN_OBJS += builtin/submodule--helper.o
 BUILTIN_OBJS += builtin/symbolic-ref.o
 BUILTIN_OBJS += builtin/tag.o
 BUILTIN_OBJS += builtin/unpack-file.o
diff --git a/builtin.h b/builtin.h
index 5d91f31ca2..3d8a173409 100644
--- a/builtin.h
+++ b/builtin.h
@@ -117,6 +117,7 @@ extern int cmd_show(int argc, const char **argv, const char *prefix);
 extern int cmd_show_branch(int argc, const char **argv, const char *prefix);
 extern int cmd_status(int argc, const char **argv, const char *prefix);
 extern int cmd_stripspace(int argc, const char **argv, const char *prefix);
+extern int cmd_submodule__helper(int argc, const char **argv, const char *prefix);
 extern int cmd_symbolic_ref(int argc, const char **argv, const char *prefix);
 extern int cmd_tag(int argc, const char **argv, const char *prefix);
 extern int cmd_tar_tree(int argc, const char **argv, const char *prefix);
diff --git a/builtin/submodule--helper.c b/builtin/submodule--helper.c
new file mode 100644
index 0000000000..cc79d059f2
--- /dev/null
+++ b/builtin/submodule--helper.c
@@ -0,0 +1,35 @@
+#include "builtin.h"
+#include "submodule.h"
+#include "strbuf.h"
+
+/*
+ * Exit non-zero if any of the submodule names given on the command line is
+ * invalid. If no names are given, filter stdin to print only valid names
+ * (which is primarily intended for testing).
+ */
+static int check_name(int argc, const char **argv, const char *prefix)
+{
+	if (argc > 1) {
+		while (*++argv) {
+			if (check_submodule_name(*argv) < 0)
+				return 1;
+		}
+	} else {
+		struct strbuf buf = STRBUF_INIT;
+		while (strbuf_getline(&buf, stdin, '\n') != EOF) {
+			if (!check_submodule_name(buf.buf))
+				printf("%s\n", buf.buf);
+		}
+		strbuf_release(&buf);
+	}
+	return 0;
+}
+
+int cmd_submodule__helper(int argc, const char **argv, const char *prefix)
+{
+	if (argc < 2)
+		usage("git submodule--helper <command>");
+	if (!strcmp(argv[1], "check-name"))
+		return check_name(argc - 1, argv + 1, prefix);
+	die(_("'%s' is not a valid submodule--helper subcommand"), argv[1]);
+}
diff --git a/git-submodule.sh b/git-submodule.sh
index 5aa3ce535e..92414dfa8b 100755
--- a/git-submodule.sh
+++ b/git-submodule.sh
@@ -229,6 +229,19 @@ get_submodule_config () {
 	printf '%s' "${value:-$default}"
 }
 
+#
+# Check whether a submodule name is acceptable, dying if not.
+#
+# $1 = submodule name
+#
+check_module_name()
+{
+	sm_name=$1
+	if ! git submodule--helper check-name "$sm_name"
+	then
+		die "$(eval_gettext "'$sm_name' is not a valid submodule name")"
+	fi
+}
 
 #
 # Map submodule path to submodule name
@@ -244,6 +257,7 @@ module_name()
 		sed -n -e 's|^submodule\.\(.*\)\.path '"$re"'$|\1|p' )
 	test -z "$name" &&
 	die "$(eval_gettext "No submodule mapping found in .gitmodules for path '\$sm_path'")"
+	check_module_name "$name"
 	printf '%s\n' "$name"
 }
 
@@ -456,6 +470,11 @@ Use -f if you really want to add it." >&2
 		sm_name="$sm_path"
 	fi
 
+	if ! git submodule--helper check-name "$sm_name"
+	then
+		die "$(eval_gettext "'$sm_name' is not a valid submodule name")"
+	fi
+
 	# perhaps the path exists and is already a git repo, else clone it
 	if test -e "$sm_path"
 	then
@@ -549,7 +568,7 @@ cmd_foreach()
 		then
 			displaypath=$(relative_path "$sm_path")
 			say "$(eval_gettext "Entering '\$prefix\$displaypath'")"
-			name=$(module_name "$sm_path")
+			name=$(module_name "$sm_path") || exit
 			(
 				prefix="$prefix$sm_path/"
 				clear_local_git_env
diff --git a/git.c b/git.c
index 9c49519831..f84ecadef2 100644
--- a/git.c
+++ b/git.c
@@ -468,6 +468,7 @@ static struct cmd_struct commands[] = {
 	{ "stage", cmd_add, RUN_SETUP | NEED_WORK_TREE },
 	{ "status", cmd_status, RUN_SETUP | NEED_WORK_TREE },
 	{ "stripspace", cmd_stripspace },
+	{ "submodule--helper", cmd_submodule__helper },
 	{ "symbolic-ref", cmd_symbolic_ref, RUN_SETUP },
 	{ "tag", cmd_tag, RUN_SETUP },
 	{ "unpack-file", cmd_unpack_file, RUN_SETUP },
diff --git a/submodule.c b/submodule.c
index c3a61e70f9..3789145572 100644
--- a/submodule.c
+++ b/submodule.c
@@ -219,6 +219,31 @@ void gitmodules_config(void)
 	}
 }
 
+int check_submodule_name(const char *name)
+{
+	/* Disallow empty names */
+	if (!*name)
+		return -1;
+
+	/*
+	 * Look for '..' as a path component. Check both '/' and '\\' as
+	 * separators rather than is_dir_sep(), because we want the name rules
+	 * to be consistent across platforms.
+	 */
+	goto in_component; /* always start inside component */
+	while (*name) {
+		char c = *name++;
+		if (c == '/' || c == '\\') {
+in_component:
+			if (name[0] == '.' && name[1] == '.' &&
+			    (!name[2] || name[2] == '/' || name[2] == '\\'))
+				return -1;
+		}
+	}
+
+	return 0;
+}
+
 int parse_submodule_config_option(const char *var, const char *value)
 {
 	struct string_list_item *config;
@@ -227,6 +252,10 @@ int parse_submodule_config_option(const char *var, const char *value)
 
 	if (parse_config_key(var, "submodule", &name, &namelen, &key) < 0 || !name)
 		return 0;
+	if (check_submodule_name(name) < 0) {
+		warning(_("ignoring suspicious submodule name: %s"), name);
+		return 0;
+	}
 
 	if (!strcmp(key, "path")) {
 		if (!value)
diff --git a/submodule.h b/submodule.h
index 7beec4822b..f0e7a71150 100644
--- a/submodule.h
+++ b/submodule.h
@@ -42,4 +42,11 @@ int find_unpushed_submodules(unsigned char new_sha1[20], const char *remotes_nam
 int push_unpushed_submodules(unsigned char new_sha1[20], const char *remotes_name);
 void connect_work_tree_and_git_dir(const char *work_tree, const char *git_dir);
 
+/*
+ * Returns 0 if the name is syntactically acceptable as a submodule "name"
+ * (e.g., that may be found in the subsection of a .gitmodules file) and -1
+ * otherwise.
+ */
+int check_submodule_name(const char *name);
+
 #endif
diff --git a/t/t7415-submodule-names.sh b/t/t7415-submodule-names.sh
new file mode 100755
index 0000000000..de95ba8034
--- /dev/null
+++ b/t/t7415-submodule-names.sh
@@ -0,0 +1,77 @@
+#!/bin/sh
+
+test_description='check handling of .. in submodule names
+
+Exercise the name-checking function on a variety of names, and then give a
+real-world setup that confirms we catch this in practice.
+'
+. ./test-lib.sh
+
+test_expect_success 'check names' '
+	cat >expect <<-\EOF &&
+	valid
+	valid/with/paths
+	EOF
+
+	git submodule--helper check-name >actual <<-\EOF &&
+	valid
+	valid/with/paths
+
+	../foo
+	/../foo
+	..\foo
+	\..\foo
+	foo/..
+	foo/../
+	foo\..
+	foo\..\
+	foo/../bar
+	EOF
+
+	test_cmp expect actual
+'
+
+test_expect_success 'create innocent subrepo' '
+	git init innocent &&
+	git -C innocent commit --allow-empty -m foo
+'
+
+test_expect_success 'submodule add refuses invalid names' '
+	test_must_fail \
+		git submodule add --name ../../modules/evil "$PWD/innocent" evil
+'
+
+test_expect_success 'add evil submodule' '
+	git submodule add "$PWD/innocent" evil &&
+
+	mkdir modules &&
+	cp -r .git/modules/evil modules &&
+	write_script modules/evil/hooks/post-checkout <<-\EOF &&
+	echo >&2 "RUNNING POST CHECKOUT"
+	EOF
+
+	git config -f .gitmodules submodule.evil.update checkout &&
+	git config -f .gitmodules --rename-section \
+		submodule.evil submodule.../../modules/evil &&
+	git add modules &&
+	git commit -am evil
+'
+
+# This step seems like it shouldn't be necessary, since the payload is
+# contained entirely in the evil submodule. But due to the vagaries of the
+# submodule code, checking out the evil module will fail unless ".git/modules"
+# exists. Adding another submodule (with a name that sorts before "evil") is an
+# easy way to make sure this is the case in the victim clone.
+test_expect_success 'add other submodule' '
+	git submodule add "$PWD/innocent" another-module &&
+	git add another-module &&
+	git commit -am another
+'
+
+test_expect_success 'clone evil superproject' '
+	test_might_fail git clone --recurse-submodules . victim >output 2>&1 &&
+	cat output &&
+	! grep "RUNNING POST CHECKOUT" output
+'
+
+test_done
-- 
2.17.0.921.gf22659ad46

