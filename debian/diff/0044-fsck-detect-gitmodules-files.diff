From 944e2f556d3f34b06eae0f4116e15f238817b138 Mon Sep 17 00:00:00 2001
From: Jeff King <peff@peff.net>
Date: Wed, 2 May 2018 17:20:08 -0400
Subject: fsck: detect gitmodules files

commit 159e7b080bfa5d34559467cacaa79df89a01afc0 upstream.

In preparation for performing fsck checks on .gitmodules
files, this commit plumbs in the actual detection of the
files. Note that unlike most other fsck checks, this cannot
be a property of a single object: we must know that the
object is found at a ".gitmodules" path at the root tree of
a commit.

Since the fsck code only sees one object at a time, we have
to mark the related objects to fit the puzzle together. When
we see a commit we mark its tree as a root tree, and when
we see a root tree with a .gitmodules file, we mark the
corresponding blob to be checked.

In an ideal world, we'd check the objects in topological
order: commits followed by trees followed by blobs. In that
case we can avoid ever loading an object twice, since all
markings would be complete by the time we get to the marked
objects. And indeed, if we are checking a single packfile,
this is the order in which Git will generally write the
objects. But we can't count on that:

  1. git-fsck may show us the objects in arbitrary order
     (loose objects are fed in sha1 order, but we may also
     have multiple packs, and we process each pack fully in
     sequence).

  2. The type ordering is just what git-pack-objects happens
     to write now. The pack format does not require a
     specific order, and it's possible that future versions
     of Git (or a custom version trying to fool official
     Git's fsck checks!) may order it differently.

  3. We may not even be fscking all of the relevant objects
     at once. Consider pushing with transfer.fsckObjects,
     where one push adds a blob at path "foo", and then a
     second push adds the same blob at path ".gitmodules".
     The blob is not part of the second push at all, but we
     need to mark and check it.

So in the general case, we need to make up to three passes
over the objects: once to make sure we've seen all commits,
then once to cover any trees we might have missed, and then
a final pass to cover any .gitmodules blobs we found in the
second pass.

We can simplify things a bit by loosening the requirement
that we find .gitmodules only at root trees. Technically
a file like "subdir/.gitmodules" is not parsed by Git, but
it's not unreasonable for us to declare that Git is aware of
all ".gitmodules" files and make them eligible for checking.
That lets us drop the root-tree requirement, which
eliminates one pass entirely. And it makes our worst case
much better: instead of potentially queueing every root tree
to be re-examined, the worst case is that we queue each
unique .gitmodules blob for a second look.

This patch just adds the boilerplate to find .gitmodules
files. The actual content checks will come in a subsequent
commit.

[jn: backported to 2.1.y:
 - using error_func instead of report to report fsck errors
 - using sha1s instead of struct object_id
 - using "struct hashmap" directly since "struct oidset" isn't
   available]

Signed-off-by: Jeff King <peff@peff.net>
Signed-off-by: Jonathan Nieder <jrnieder@gmail.com>
---
 fsck.c | 83 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 fsck.h |  7 +++++
 2 files changed, 90 insertions(+)

diff --git a/fsck.c b/fsck.c
index 6863ae6e92..989e72408a 100644
--- a/fsck.c
+++ b/fsck.c
@@ -7,6 +7,41 @@
 #include "tag.h"
 #include "fsck.h"
 #include "utf8.h"
+#include "hashmap.h"
+
+struct oidhash_entry {
+	struct hashmap_entry ent;
+	unsigned char sha1[20];
+};
+
+static int oidhash_hashcmp(const void *va, const void *vb,
+			   const void *vkey)
+{
+	const struct oidhash_entry *a = va, *b = vb;
+	const unsigned char *key = vkey;
+	return hashcmp(a->sha1, key ? key : b->sha1);
+}
+
+static struct hashmap gitmodules_found;
+static struct hashmap gitmodules_done;
+
+static void oidhash_insert(struct hashmap *h, const unsigned char *sha1)
+{
+	struct oidhash_entry *e;
+
+	if (!h->tablesize)
+		hashmap_init(h, oidhash_hashcmp, 0);
+	e = xmalloc(sizeof(*e));
+	hashmap_entry_init(&e->ent, sha1hash(sha1));
+	hashcpy(e->sha1, sha1);
+	hashmap_add(h, e);
+}
+
+static int oidhash_contains(struct hashmap *h, const unsigned char *sha1)
+{
+	return h->tablesize &&
+		!!hashmap_get_from_hash(h, sha1hash(sha1), sha1);
+}
 
 static int fsck_walk_tree(struct tree *tree, fsck_walk_func walk, void *data)
 {
@@ -173,6 +208,10 @@ static int fsck_tree(struct tree *item, int strict, fsck_error error_func)
 		has_dotdot |= !strcmp(name, "..");
 		has_dotgit |= is_hfs_dotgit(name) || is_ntfs_dotgit(name);
 		has_zero_pad |= *(char *)desc.buffer == '0';
+
+		if (is_hfs_dotgitmodules(name) || is_ntfs_dotgitmodules(name))
+			oidhash_insert(&gitmodules_found, sha1);
+
 		update_tree_entry(&desc);
 
 		switch (mode) {
@@ -409,3 +448,47 @@ int fsck_error_function(struct object *obj, int type, const char *fmt, ...)
 	strbuf_release(&sb);
 	return 1;
 }
+
+int fsck_finish(fsck_error error_func)
+{
+	int retval = 0;
+	struct hashmap_iter iter;
+	const struct oidhash_entry *e;
+
+	hashmap_iter_init(&gitmodules_found, &iter);
+	while ((e = hashmap_iter_next(&iter))) {
+		const unsigned char *sha1 = e->sha1;
+		struct blob *blob;
+		enum object_type type;
+		unsigned long size;
+		char *buf;
+
+		if (oidhash_contains(&gitmodules_done, sha1))
+			continue;
+
+		blob = lookup_blob(sha1);
+		if (!blob) {
+			retval += error_func(&blob->object, FSCK_ERROR,
+					     "non-blob found at .gitmodules");
+			continue;
+		}
+
+		buf = read_sha1_file(sha1, &type, &size);
+		if (!buf) {
+			retval += error_func(&blob->object, FSCK_ERROR,
+					     "unable to read .gitmodules blob");
+			continue;
+		}
+
+		if (type == OBJ_BLOB)
+			retval += fsck_blob(blob, buf, size, error_func);
+		else
+			retval += error_func(&blob->object, FSCK_ERROR,
+					     "non-blob found at .gitmodules");
+		free(buf);
+	}
+
+	hashmap_free(&gitmodules_found, 1);
+	hashmap_free(&gitmodules_done, 1);
+	return retval;
+}
diff --git a/fsck.h b/fsck.h
index d1e6387a44..06a09771ee 100644
--- a/fsck.h
+++ b/fsck.h
@@ -32,4 +32,11 @@ int fsck_walk(struct object *obj, fsck_walk_func walk, void *data);
 int fsck_object(struct object *obj, void *data, unsigned long size,
 	int strict, fsck_error error_func);
 
+/*
+ * Some fsck checks are context-dependent, and may end up queued; run this
+ * after completing all fsck_object() calls in order to resolve any remaining
+ * checks.
+ */
+int fsck_finish(fsck_error error_func);
+
 #endif
-- 
2.17.0.921.gf22659ad46

